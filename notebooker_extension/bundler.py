import git
import json
import os
import re
import stashy
import traceback
import uuid
from ahl.manorapass import get_credentials, Credentials
from typing import Optional, List, Dict, Any

from man.notebooker.utils.conversion import generate_py_from_ipynb

PROJECT_KEY = 'DATA'
REPOSITORY = 'man.notebooker'
BRANCH_NAME = '{user}/extension-submission-{id}'


def _jupyter_bundlerextension_paths():
    return [{
        'group': 'deploy',  # group under 'deploy' or 'download' menu
        'label': 'To BitBucket as .py',  # human-redable menu item label
        'name': 'bitbucket_bundler',  # unique bundler name
        'module_name': 'notebooker_extension.bundler',  # module containing bundle()
    }]


def get_git_repo(path):
    # type: (str) -> git.Repo
    # Get the top level directory of the git repository
    repo_dir = git.Git(os.path.dirname(path)).rev_parse('--show-toplevel')
    repo = git.Repo(repo_dir)
    repo.git.fetch()
    return repo


def git_rebase_on_master(repo):
    repo.git.stash()
    repo.git.pull('origin', 'master')
    repo.git.stash('pop')


def connect_to_stash(repo, credentials):
    # type: (git.Repo, Credentials) -> stashy.Client
    # Get the hostname of our BitBucket instance
    url = repo.remotes[0].url
    hostname = re.search(r"(https?|ssh)://(.+@)?(?P<host>[^:/\s]+)", url).group("host")
    stash_url = 'http://' + hostname
    stash = stashy.connect(stash_url, credentials.user, credentials.password)
    remote_repo = stash.projects[PROJECT_KEY].repos[REPOSITORY]
    return remote_repo


def do_convert_to_py(path):
    # type: (str) -> str
    # yields the path of the converted python file
    if os.path.splitext(path)[1] == '.py':
        # Handle the case where we are just given a python file instead of .ipynb
        return path
    else:
        return generate_py_from_ipynb(path, os.path.dirname(path))


def get_base_commit(repo, path):
    # type: (git.Repo, str) -> Optional[str]
    # Returns a commit hex if modified, None if the file is new
    try:
        # If this line doesn't raise an error, the file already exists on HEAD
        repo.git.fetch()
        repo.git.cat_file('-e', 'origin/master:{}'.format(path))
        from_commit = repo.iter_commits('origin/master').next().hexsha
    except git.GitCommandError:
        from_commit = None
    return from_commit


def send_file_to_stash(stash, repo_file_path, content_to_send, branch_name, from_commit, creds):
    # type: (stashy.Client, str, str, str, str, Credentials) -> None
    resp = stash._client.put(stash.url() + '/browse/' + repo_file_path,
                             files={'content': content_to_send,
                                    'message': 'Submitting from Jupyter using rest api',
                                    'branch': branch_name,
                                    'sourceCommitId': from_commit,
                                    'sourceBranch': 'master',
                                    },
                             auth=(creds.user, creds.password))
    resp.raise_for_status()


def get_default_reviewers(stash):
    # type: (stashy.Client) -> List[str]
    pr_settings_url = 'default-reviewers/1.0/projects/{}/repos/{}/conditions'.format(PROJECT_KEY, REPOSITORY)
    reviewers_resp = stash._client.get(pr_settings_url)
    reviewers = json.loads(reviewers_resp.content)[0]['reviewers']
    default_reviewers = [r['name'] for r in reviewers]
    return default_reviewers


def create_pull_request(stash, branch, pr_title):
    # type: (stashy.Client, str, str) -> Dict[Any, Any]
    default_reviewers = get_default_reviewers(stash)

    pr_req = stash.pull_requests.create(pr_title,
                                        branch,
                                        'master',
                                        'Change automatically generated by notebooker extension',
                                        reviewers=default_reviewers)
    return pr_req


def bundle(handler, model):
    """Transform, convert, bundle, etc. the notebook referenced by the given
    model.

    Then issue a Tornado web response using the `handler` to redirect
    the user's browser, download a file, show a HTML page, etc. This function
    must finish the handler response before returning either explicitly or by
    raising an exception.

    Parameters
    ----------
    handler : tornado.web.RequestHandler
        Handler that serviced the bundle request
    model : dict
        Notebook model from the configured ContentManager
    """
    try:
        repo = get_git_repo(model['path'])
        # git_rebase_on_master(repo)

        # Jupytext - convert .ipynb to .py
        py_file = do_convert_to_py(model['path'])

        # Log into stash
        creds = get_credentials('windows')
        stash = connect_to_stash(repo, creds)

        # Get the relative path of our modified .py file within the git repository
        repo_file_path = os.path.relpath(py_file, repo.working_tree_dir)
        content_to_send = open(py_file).read()

        # Determine which commit we are basing from and whether we are creating a new file.
        from_commit = get_base_commit(repo, repo_file_path)

        # Submit the file change to BitBucket on a new branch
        branch = BRANCH_NAME.format(user=creds.user, id=str(uuid.uuid4())[:6])
        send_file_to_stash(stash, repo_file_path, content_to_send, branch, from_commit, creds)

        # Create our pull request!
        action = 'Modifying' if from_commit else 'Creating'
        pr_title = '{} {}'.format(action, os.path.splitext(repo_file_path)[0])
        pr_req = create_pull_request(stash, branch, pr_title)
        pr_url = pr_req['links']['self'][0]['href']
        print('Successfully created pull request at {}'.format(pr_url))
        handler.finish('<script>window.location.href = "{url}"</script>'
                       'Successfully created at <a href="{url}">{url}</a>'.format(url=pr_url))
    except Exception as e:
        handler.finish('Failed. Please deploy from a clean notebooker git repo '
                       'which you have checked out locally.<br/><br/>' + traceback.format_exc().replace('\n', '<br/>'))
        print(traceback.format_exc())
        return
